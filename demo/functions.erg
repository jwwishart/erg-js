// TODO(jwwishart) MOVE EXPRESSION TESTS OUT INTO expressions.erg
// TODO(jwwishart) should these programs have a main() function?
// TODO(jwwishart) should this be an issue? not declared yet?
// TODO(jwwishart) try other types
// TODO(jwwishart) try variable list of expression parts
// TODO(jwwishart) undeclared variabls in function argument expressions don't get picked up
//   EX: print(me_no_exist)
// TODO(jwwishart) return types optional
// TODO(jwwishart) infer return type 
// TODO(jwwishart) assign result value to variable and validate types
// TODO(jwwishart) multiple arguments
// TODO(jwwishart) argument type checking
// TODO(jwwishart) identifier exists in scope already (i.e. function with same name exists in same sccope)
// TODO(jwwishart)
// TODO(jwwishart)
// TODO(jwwishart)


print("--- Simple Tests -----------------------------");

error :: (message) {
    print("ERROR: " + message);
}

info :: (message) {
    print("INFO: " + message);
}

log :: (message) {
    print("LOG: " + message);
}

anotherError :: (m1, m2, m3) {
    print("another error: " + m1 + ", " + m2 + ", " + m3);
}

error("AARRGGGHH");
info("Did you know!");
log("This is cool");
anotherError("one", "two", "three");




print("--- Return Types -----------------------------");
/*
    TODO:
    + no return type specified and no return (this is already good!)
    - no return type but something is returned (return type is Any)
    - Verify all code paths return something!
        Last statement is a 'return' statement 
        OR all paths have a return statement (like if else, both need 'return'!)
    - 

    ERRORS:
    -  no return type and return statement not allowed!
    - 
*/





print("--- Multiple Arguments -----------------------------");

where_in :: (the : bool, world : string) {
    print(world + " " + the);
}
where_in(false, "Is code the world? ");

/* Error Conditions -----------------------------

// TODO(jwwishart) calling this throw an error: "function call to where_in expects 3 arguments but was provided 2"
where_in :: (the bool, world : string) {
    print(world + the);
}
*/



print("--- Argument Type Checking -----------------------------");

error("error(string)");
error(1);
error(10.10);
error(false);
error(true);

// TODO(jwwishart) Arrays and structures don't exist yet!
//error({});
//error([]);

only_takes_string :: (message : string) {
    print(message);
}

only_takes_string("cool");
/* --- Error Conditions ------
only_takes_string(12.121212); // Expected a string, but got a float
*/




print("--- Function call expression ordering -----------------------------");

// Args to function can be literal then variable
// @BUG this should 
literal_then_message :: (message) { print("TEST: " + message); }
literal_then_message("test");

// Args to function can be variable then literal
message_then_literal :: (message) {
    print(message + " < was the message");
}
message_then_literal("test");



print("--- Invalid Declarations -----------------------------");
/* -- ERROR CONDITIONS -------------------------------

// This should fail as := is not valid! for function (OR SHOULD IT DECLARE A FUNCITON POINTER to a given function type??????)
literal_then_message := (message) { print("TEST: " + message); }

*/