Backlog
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

- Type system
    Need to clarify 1 how builtin types and custom types
    are defined and recorded in the complier and how
    they are referenced and used for type inference etc.
- 



Variables ---
- String escape characters
- multiple line here strings style stuff.
- 

Structs ---
- 

Function ---
- multiple arguments
- any type can be parsed
- argument expressions evaluated (after general expression parsing done)
- returning reuslts
- multiple return results.


Syntax and Keywords ---
- defer
    x function calls only for statements
    - need to separate declarations and identifiers
      so that they are outside the try :oS (function
      identifiers must be outside... variables might be fine??? 
- lambda's
- closures
- using statement (any context: program, file,  function/block etc... for/if/etc blocks


Compiler Functionality ---
- type inference
- type checking
- es6 classes for structs?
- dependency system
- out of order type inference etc...


Modules ---
- a module should be a folder of erg files that should be compiled into one file or brought into the full file
- If you want to compile a program that includes multiple modules you should either have to specify the start file or have a main.erg file which is the start point for the application to build from. 
- Only imported modules or modules imported along the way will be included in the final build
- compiler options should allow specification that modules can be complied into a single file per module or into the whole application (1 file) or as separate files? How you would bring them together is another question in that last case.
- when building modules a module-exports.json file should be created which contains all exports for easy importing... it should be quick to load this into the compiler into the AST structure so that we don't have to parse the files again. a last-build.json file could have timestamps of the last time the files were compiled and whether we need to compiled them agian or not.
- 



structs enums   type checking   type checking   type checking
assign literal to var or arg { k : val } expecting a struct. must provide all non nullable properties and warn on unset nullables   type inference  type inference  delegates. DelegateNameTitleCase :: delegate (string, int) => string.  use. myvar : DelegateNameTitleCase = ---; myfunc :: (callback : DelegateNameTitleCase) { ••• }   inline func arg decl. myfunc :: (delegate (string, int) => string)... how to distinguish from inline anonymous function declaration? 
value types. declare a struct that cannot be null   struct args nullable. struct { one : String,  two? : string }   void function return type.. do soon struct methods, like go lang    string escape characters
char data type  herestrings..., @ in c# or like jon does it.            
    unions. . see how type script implements them.  myunion :: union {  x : int | float } you can only assign one of those types. .. maybe you should be able to have is_x_int : bool and is_x_float : bool.. then x_as_int : int and x_as_float : float... Instead of having to cast. .. also a x_ type : type for switches etc.   using. file level allows import of modules. using conversion; using conversion.json; this imports all functions into current space. this ought to be able to be done at ANY SCOPE I.e. in a block have a using to import one module into that block.  you should even be able to just import a single function or struct etc.  this incluses function scope etc. enums could be impoerted into a block of a function without polutong everything putside it... this is clpse to context imports.... reduces clutter at top of file and maintaining it. should be able to go #using git "git@github.com" ...style import and it should be downloaded an built if it is an erg program build.erg file ar root.    functions can be defined like extension methods in c# and they should be callable like functions or as methods off of an iddntifier of said type... parseint :: (arg : this string) int.  . called like parseint(150) or "134".parseint() or mystr.parseint ()... static type helpers might be good... int.parse() where int is the class Int... declaration would be parse :: (arg : string) this int  then int.parse ("1849") would be valid. where the this is is where iit is associated. maybe attach-to might be better... I.e. a more descriptive keyword.   I
out of order type inference... I.e. struct declared after first lexical use.typescript uses bottom up inference normally then top down. might need to iterate ast and filk in info latter as simplest solution....              