Backlog
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

--- TYPE SYSTEM NOTES ----------------------------------

Some type examples:
    // TODO(jwwishart) why the core.String etc? ...
    //  Answer: we might have functions of them? (Extension methods)
    //  ANSWER: 
    - string (core.String type)
    - int (core.Int type)
    - float (core.Float type)
    - decimal (core.Decimal type);
        - will be a special object for calculation of precise values like money)
    - bool (core.Boolean type)
    - any (core.Any type);
    - null ??? assignable to non primitive types only?
    - void ??? for placs where no value returned?? funcs only?

    - function (core.Function type)
        - is lambda?
        - closed over variables (Explicity ??)
        - return type list (multiple results potentially)
        - argument type list

    - struct (core.Structure type);

    - enum
        - Start off with simple enums as constants!
          essentially any use of enum value will be
          replaced in places enum is used... ?
        - only numeric types allowed OR LOOK AT RUST style enums? (java enums?)

    - array (core.Array type)
        - should be dynamic and non-dynamic type arrays?

Types should all have builting type definitions
and the keywords are just supporting specification of 
the given type definition in a keyword format.

We need to know:
    - identifier

    - is_resolved

    - default_value ???

    - is_primitive (string, int, float, bool etc);
    - is_null
    - is_void

    - is_function
    - is_struct
    - is_enum
    - is_array

    // This information is so we can re-try determination
    // of the type and comparison of type information
    - identifier_declaration (function, variable, struct etc)
    - scope_of_declaration (where above decl is declared)
    // So the quesiton is ... what about expressions where an identiifier is used... we would have to re-process the types for all expression parts and then re-evaluate whether the expression types match appropriately and then determine whether the expression (say a binary expression) is appropriate in the given context (say an if statement or as an argument to a function....
    SO we essentially have a bottom up parsing of the AST... to validate everything is ok??

Scenarios:
    Variable Declaration
        - The identifier is determined
        - We have type name
        - Find the TypeDefinition in the hierarchy... or in imported modules and associate
        - the type inforamation WITH the variable declaration
    Variable Declaration type inference
        - The indetnfier is determined
        - We have a constant assignment at declaration site
        - Determine the tyep and find the TypeDeclaration
    Variable Declaration with Constant assignement where const is declared after variable declaration
        - The identifier is determined
        - we have assignment of identifier
        - we can't determine the identifiers type as it is not be processed yet
        - we construct a TypeDefinition with identifier and mark it as is_resolved = false... and we assign it to the program for later processing
        - When compilation is done as much as possible we will then process the TypeDEfinition objects on the program which we will then re-try determination of the TypeDefiniitions

    Function Declaration (Same as varibles essentially)

    Assignment
        - identifier is ok
        - assigned value might be anything (expression, function call etc)
        - might not have 

        Case Example:

        result := is_this_ok("password");

        TypeDefinition would not be found for 

THIS ALL MAKES ME THINK THAT I NEED TO JUST PARSE THE THING
AND FORGET ABOUT TYPE CHECKING ERRORS AND DO IT IN A SEPARATE
PARSE AS I WILL HAVE TO DO IT FOR ALL CASES AFTER COMPILATION
ANYWAY AS I

--------------------------------------------------------




Variables ---
- String escape characters
- multiple line here strings style stuff.
- 

Structs ---
- 

Function ---
- multiple arguments
- any type can be parsed
- argument expressions evaluated (after general expression parsing done)
- returning reuslts
- multiple return results.


Syntax and Keywords ---
- defer
    x function calls only for statements
    - need to separate declarations and identifiers
      so that they are outside the try :oS (function
      identifiers must be outside... variables might be fine??? 
- lambda's
- closures
- using statement (any context: program, file,  function/block etc... for/if/etc blocks


Compiler Functionality ---
- type inference
- type checking
- es6 classes for structs?
- dependency system
- out of order type inference etc...


Modules ---
- a module should be a folder of erg files that should be compiled into one file or brought into the full file
- If you want to compile a program that includes multiple modules you should either have to specify the start file or have a main.erg file which is the start point for the application to build from. 
- Only imported modules or modules imported along the way will be included in the final build
- compiler options should allow specification that modules can be complied into a single file per module or into the whole application (1 file) or as separate files? How you would bring them together is another question in that last case.
- when building modules a module-exports.json file should be created which contains all exports for easy importing... it should be quick to load this into the compiler into the AST structure so that we don't have to parse the files again. a last-build.json file could have timestamps of the last time the files were compiled and whether we need to compiled them agian or not.
- 



structs enums   type checking   type checking   type checking
assign literal to var or arg { k : val } expecting a struct. must provide all non nullable properties and warn on unset nullables   type inference  type inference  delegates. DelegateNameTitleCase :: delegate (string, int) => string.  use. myvar : DelegateNameTitleCase = ---; myfunc :: (callback : DelegateNameTitleCase) { ••• }   inline func arg decl. myfunc :: (delegate (string, int) => string)... how to distinguish from inline anonymous function declaration? 
value types. declare a struct that cannot be null   struct args nullable. struct { one : String,  two? : string }   void function return type.. do soon struct methods, like go lang    string escape characters
char data type  herestrings..., @ in c# or like jon does it.            
    unions. . see how type script implements them.  myunion :: union {  x : int | float } you can only assign one of those types. .. maybe you should be able to have is_x_int : bool and is_x_float : bool.. then x_as_int : int and x_as_float : float... Instead of having to cast. .. also a x_ type : type for switches etc.   using. file level allows import of modules. using conversion; using conversion.json; this imports all functions into current space. this ought to be able to be done at ANY SCOPE I.e. in a block have a using to import one module into that block.  you should even be able to just import a single function or struct etc.  this incluses function scope etc. enums could be impoerted into a block of a function without polutong everything putside it... this is clpse to context imports.... reduces clutter at top of file and maintaining it. should be able to go #using git "git@github.com" ...style import and it should be downloaded an built if it is an erg program build.erg file ar root.    functions can be defined like extension methods in c# and they should be callable like functions or as methods off of an iddntifier of said type... parseint :: (arg : this string) int.  . called like parseint(150) or "134".parseint() or mystr.parseint ()... static type helpers might be good... int.parse() where int is the class Int... declaration would be parse :: (arg : string) this int  then int.parse ("1849") would be valid. where the this is is where iit is associated. maybe attach-to might be better... I.e. a more descriptive keyword.   I
out of order type inference... I.e. struct declared after first lexical use.typescript uses bottom up inference normally then top down. might need to iterate ast and filk in info latter as simplest solution....              